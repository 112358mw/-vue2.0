

 这里的一个关键点是巧妙的利用了闭包的特性, 稍微解释一下:


  key 为a 的时候, new出来的dep ( 取个别名 dep(a) )

  dep(a) 这个活动变量 分别被 get 和 set函数引用;

  而get和 set又被 Object引用, 所以形成了闭包,

  defineReactive 执行完好, dep(a)没有释放...


  闭包比较特殊, get和set中的作用域已经确定, 不像普通函数执行的时候才确定,
 
  所以get和set保存的都是父级函数defineReactive 的变量dep(a)

  这就使得, 访问this.a, 设置值 this.a=1 的时候保证触发的这两个函数
  
  的dep是同一个 dep, 即dep(a);   dep(a) 存放依赖 a属性的 订阅者. 

  
  如果不用闭包也可以实现, 外面定义一个deps ={  },
 
  key 为 a的时候,  在get 函数  dep = deps.data.a = new Dep()

                   在set函数   deps.data.a.notify()